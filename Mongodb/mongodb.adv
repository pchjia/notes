1. 在mongodb中使用js语法
    > for (var i=0; i<10000; i++) {
            db.test.insert({_id: i+1, title: 'hello world!', content: 'this is the ' + i+1 + 'th article.'});
        };
    > db.test.find().count();

2. 游标操作 cursor
    游标不是查询结果，而是查询的接口。通过游标，可以逐条读取，类似文件流。
    var cursor = db.collection_name.find(query, projection)
    cursor.hasNext()    # 判断是否有下一项
    cursor.next()       # 获取下一项，bson对象
    printjson(cursor.next()) # 以json格式打印出来

    forEach 回调函数
        var cursor = db.collection_name.find(query, projection)
        var detail = finction(obj) {
            print('your id is ' + obj_id);
            printjson(obj);
        }
        cursor.forEach(detail);

        <=>
        cursor.forEach(function(obj) printjson(obj))
    分页中的使用
        查到10000行，跳过100页，取10行
        mysql: limit offset, N
        mongodb: skip() limit()
        var cursor = db.test.find().skip(100*10).limit(10)        # 跳过前100页，每页10行，再取10行
        <=> db.test.find().skip(100*10).limit(10)

    toArray() 将结果以数组形式返回，此操作会把所有的行立即以对象的形式组织在内存中，一般取少数几行时用此功能
        var cursor = db.test.find()
        curson.toArray()

3. 索引 加索引会提高查询速度，也会减慢插入速度，默认是用btree来组织索引文件
    db.collection_name.ensureIndex({a: 1/-1})                       # 将a列按升序/降序建立索引，不存在的列建立索引值为null
    db.collection_name.getIndexes()                                 # 查看当前索引

    db.collection_name.createIndex({a: 1})                          # 创建索引
    db.collection.createIndex( { a: 1, b: 1, c: 1 } )               # 创建多列索引
    db.collection.createIndex( { a: 1 }, { unique: true } )         # 创建唯一索引，取值不重复的列
    db.collection.createIndex( { a: 1, b: 1 }, { unique: true } )   # 创建多列的唯一索引

    db.collection.createIndex(
       { a: 1 },
       { partialFilterExpression: { b: { $gt: 5 } } }
    )                                       # 创建局部索引

    db.collection.createIndex( { a: 1 }, { sparse: true } )         # 创建稀疏索引，不含此列不建立索引
    db.collection.createIndex( { _id: "hashed" } )                  # 创建hash索引
    db.collection.createIndex({'a.b':1})    # 子文档加索引，用点表示引用子文档

    db.collection.dropIndex({a: -1})        # 删除索引
    db.collection.dropIndexes()             # 删除所有索引

    修改索引需要删除索引并重新建立索引

    db.accounts.reIndex()   # 重建索引，减少碎片，集合经过一段时间的修改后，表中的文件容易出现空洞，查询效率不高


注明:
    子文档查询：
        db.user.insert({name: 'pc', subject: {math: 90, english: 90}})
        db.user.find({'subject.math': {$exists: 1}}, {_id: 0,'subject.math':1})

4. 用户管理
    mongodb中有一个admin数据库
    mongodb中用户以数据库为单位，每个数据库都有自己的管理员，先在admin中建立超级管理员，再管理其他数据库
    启动mongodb时需要加上--auth选项

    db.createUser({ user: "<name>",
      pwd: "<cleartext password>",
      customData: { <any information> },
      roles: [
        { role: "<role>", db: "<database>" } | "<role>",
        ...
      ]
    })

    db.createUser({user: 'pchjia', pwd: 'jia9692', roles: []})
    db.createUser({user: 'pchjia', pwd: 'jia9692', roles: [{role: 'clusterAdmin', db: 'admin'}, {role: 'readAnyDatabase', db: 'admin'}, 'readWrite', 'dbOwner']})

    use admin
    db.auth('user_name', 'password')

    see: built-in roles
        https://docs.mongodb.org/manual/reference/built-in-roles/#database-administration-roles

    db.dropUser('user_name')

    db.revokeRolesFromUser(
        "reportsUser",
        [
          { role: "readWrite", db: "accounts" }
        ]
    )

    db.grantRolesToUser(
        "reportsUser",
        [
          { role: "read", db: "accounts" }
        ]
    )

    db.changeUserPassword("user_name", "new_password")
